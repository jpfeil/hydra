import numpy as np
import skimage.io

def generate_patches_for_symbol(Lstr, N=1000, PRNG=np.random.RandomState(0)):
	''' Create many patches from cluster associated with specified symbol

	Args
	----
	Lstr : str, name of symbol
		Examples: 'A', 'B', ... 'Z', 'slash', etc

	Returns
	-------
	X_ND : 2D array, N x 64
	'''
	CovMat = patchname2covmat_cached(Lstr)
	X_ND = PRNG.multivariate_normal(
		np.zeros(64), CovMat, size=N)
	return X_ND

def str2imarr(s):
	''' Convert a string with 64 characters into an 8x8 array

	Args
	----
	s : str
		has exactly 64 characters

	Returns
	-------
	arr : 2D array, size 8 x 8
	'''
	assert len(s) == 64
	valList = list()
	for c in s:
		valList.append(int(c))
	return np.asarray(valList, dtype=np.int32).reshape((8,8))

Cache = dict()
def patchname2covmat_cached(Lstr):
	if Lstr not in Cache:
		Cache[Lstr] = patchname2covmat(Lstr)
	return Cache[Lstr]

def patchname2covmat(Lstr, N=1000, sig=0.01):
	''' Convert string name to covariance matrix

	Returns
	-------
	CovMat : 2D array, D x D 
	'''
	PRNG = np.random.RandomState(N)
	if len(Lstr) == 1:
		Lim = str2imarr(globals()[Lstr])
	else:
		Lim = str2imarr(Pdict[Lstr])
	# Generate N samples with random noise, with on pixels having POS vals
	Xall = np.zeros((2*N, 8**2))
	for n in range(N):
		Xim = Lim + sig * PRNG.randn(8,8)
		#Xim = (1 + PRNG.rand()) * Lim + sig * PRNG.randn(8,8)
		Xim -= np.mean(Xim)
		Xall[n] = Xim.flatten()
	# Generate 100 samples with random noise, with on pixels having NEG vals
	for n in range(N):
		Xim = -1 * Lim + sig * PRNG.randn(8,8)
		#Xim = -(1 + PRNG.rand()) * Lim + sig * PRNG.randn(8,8)
		Xim -= np.mean(Xim)
		Xall[N+n] = Xim.flatten()
	CovMat = np.dot(Xall.T, Xall) / (2*N)
	CovMat += 1e-11 * np.eye(CovMat.shape[0]) # need to make pos definite
	return CovMat

Pdict = dict()
Pdict['blank'] = (
	"00000000" + 
	"00000000" + 
	"00000000" + 
	"00000000" + 
	"00000000" + 
	"00000000" + 
	"00000000" + 
	"00000000"
	)
Pdict['horiz_half'] = (
	"11111111" + 
	"11111111" + 
	"11111111" + 
	"11111111" + 
	"00000000" + 
	"00000000" + 
	"00000000" + 
	"00000000"
	)
Pdict['diag_half'] = (
	"00000000" + 
	"00000011" + 
	"00000111" + 
	"00001111" + 
	"00011111" + 
	"00111111" + 
	"01111111" + 
	"11111111"
	)
Pdict['slash'] = (
	"00000011" + 
	"00000111" + 
	"00001110" + 
	"00011100" + 
	"00111000" + 
	"01110000" + 
	"11100000" + 
	"11000000"
	)
Pdict['vert_half'] = (
	"00001111" + 
	"00001111" + 
	"00001111" + 
	"00001111" + 
	"00001111" + 
	"00001111" + 
	"00001111" + 
	"00001111"
	)
Pdict['cross'] = (
	"00011000" + 
	"00011000" + 
	"00011000" + 
	"11111111" + 
	"11111111" + 
	"00011000" + 
	"00011000" + 
	"00011000"
	)

A = (
	"00011000" + 
	"01100110" + 
	"01100110" + 
	"11111111" + 
	"11111111" + 
	"11000011" + 
	"11000011" + 
	"11000011"
	)

B = (
	"11110000" +
	"11000111" +
	"11000111" +
	"11111000" +
	"11111000" +
	"11000111" +
	"11000111" +
	"11111000"
	)

C = (
	"11111111" +
	"11111111" +
	"11000000" +
	"11000000" +
	"11000000" +
	"11000000" +
	"11111111" +
	"11111111"
	)

D = (
	"11111000" +
	"11111111" +
	"11000111" +
	"11000011" +
	"11000011" +
	"11000111" +
	"11111111" +
	"11111000"
	)

E = (
	"11111111" +
	"11111111" +
	"11000000" +
	"11111000" +
	"11111000" +
	"11000000" +
	"11111111" +
	"11111111"
	)

F = (
	"11111111" +
	"11111111" +
	"11000000" +
	"11111000" +
	"11111000" +
	"11000000" +
	"11000000" +
	"11000000"
	)

G = (
	"11111111" +
	"11111111" +
	"11000000" +
	"11000000" +
	"11001111" +
	"11000011" +
	"11111111" +
	"11111111"
	)

H = (
	"11000011" + 
	"11000011" + 
	"11000011" + 
	"11111111" + 
	"11111111" + 
	"11000011" + 
	"11000011" + 
	"11000011"
	)

I = (
	"11111111" + 
	"11111111" + 
	"00011000" +
	"00011000" +
	"00011000" +
	"00011000" +
	"11111111" + 
	"11111111" 
	)

J = (
	"11111111" + 
	"11111111" + 
	"00011000" +
	"00011000" +
	"10011000" +
	"11011000" +
	"11111000" + 
	"11111000" 
	)

K = (
	"11000011" + 
	"11000111" + 
	"11001100" + 
	"11111000" + 
	"11111000" + 
	"11001100" + 
	"11000111" + 
	"11000011"
	)

L = (
	"11000000" + 
	"11000000" + 
	"11000000" + 
	"11000000" + 
	"11000000" + 
	"11000000" + 
	"11111111" + 
	"11111111"
	)

M = (
	"11000011" + 
	"11100111" + 
	"11100111" + 
	"11011011" + 
	"11011011" + 
	"11000011" + 
	"11000011" + 
	"11000011"
	)

N = (
	"11000011" + 
	"11100011" + 
	"11100011" + 
	"11011011" + 
	"11011011" + 
	"11000111" + 
	"11000111" + 
	"11000011"
	)


O = (
	"11111111" + 
	"11111111" + 
	"11000011" + 
	"11000011" + 
	"11000011" + 
	"11000011" + 
	"11111111" + 
	"11111111"
	)

P = (
	"11111111" + 
	"11100111" + 
	"11000011" + 
	"11100111" + 
	"11111111" + 
	"11000000" + 
	"11000000" + 
	"11000000" 
	)

Q = (
	"11111110" + 
	"11000110" + 
	"11000110" + 
	"11000110" + 
	"11000110" + 
	"11010110" + 
	"11111110" +
	"00000011" 
	)


R = (
	"11111111" + 
	"11100111" + 
	"11000011" + 
	"11100111" + 
	"11111111" + 
	"11110000" + 
	"11001110" + 
	"11000011" 
	)


S = (
	"00011111" + 
	"01111111" + 
	"11100000" + 
	"01111000" + 
	"00011110" + 
	"00000011" + 
	"11111110" + 
	"11111000"
	)

T = (
	"11111111" + 
	"11111111" + 
	"00011000" + 
	"00011000" + 
	"00011000" + 
	"00011000" + 
	"00011000" + 
	"00011000" 
	)

U = (
	"11000011" + 
	"11000011" + 
	"11000011" + 
	"11000011" + 
	"11000011" + 
	"11000011" + 
	"11111111" + 
	"11111111"
	)


V = (
	"11000011" + 
	"11000011" + 
	"11000011" + 
	"11000011" + 
	"11000011" + 
	"01000010" + 
	"00111100" + 
	"00011000"
	)

W = (
	"11000011" +
	"11000011" + 
	"11000011" + 
	"11011011" + 
	"11011011" + 
	"11100111" + 
	"11100111" + 
	"11000011"  
	)

X = (
	"11000011" + 
	"11100111" + 
	"01100110" + 
	"00011000" + 
	"00011000" + 
	"01100110" + 
	"11100111" + 
	"11000011"
	)

Y = (
	"11000011" + 
	"11100111" + 
	"01100110" + 
	"00011000" + 
	"00011000" + 
	"00011000" + 
	"00011000" + 
	"00011000" 
	)

Z = (
	"11111111" + 
	"11111111" + 
	"00000110" + 
	"00011000" + 
	"00011000" + 
	"01100000" + 
	"11111111" + 
	"11111111" 
	)

